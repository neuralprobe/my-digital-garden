---
title: 연산자 오버로딩
date: 2023-05-25
tags: C++ OOP OperatorOverloading
---

# 연산자 오버로딩

- 앞선 [[객체지향프로그래밍의 시작]]에서 만든 MyString 클래스의 멤버함수 중 
	- `compare` 함수를 `==` operator로 바꾸자!
	- `insert` 함수를 `+` operator로 바꾸자!
	- `at` 함수를 `[]` operator로 바꾸자!
```cpp
	if(str1.compare(str2)==0) { ... }
->  if(str1 == str2) { ... } // 더 자연스러운 표현!!

	str1.insert(str1.length(), str2)
->  str1 = str1 + str2; // 더 자연스러운 표현!!

	x = str1.at(10);
->  x = str1[10]; // 더 자연스러운 표현!!
```

- 어떤 연산자가 오버로딩 할 수 있냐면 ....
	- `::`연산자 (범위 지정), `.` 연산자 (멤버 지정) , `*` (멤버 포인터로 멤버 지정) 을 제외한 모든 연산자를 오버로딩 할 수 있음.

![[Pasted image 20230524122457.png]]

---

# MyString의 == 연산자 오버로딩

- 오버로딩할 연산자 함수 선언 형식
	- `{리턴타입} operator{연산자}({연산자가 받는 인자})`
	- eg. `bool operator==(MyString& str)`
		- 그러면 .. `if (str1 == str2)` 처럼 `==` 연산자 사용가능
		- 비교하는 함수인 `compare`도 만들어 놨으니깐, 아래처럼 재활용하자

```cpp
class MyString {
	public:
		...
		bool operator==(MyString& str);
};

bool MyString::operator==(MyString& str) { 
	return !compare(str); 
	// *this와 str이 같으면 compare 에서 0 을 리턴
}	
```

---

# 복소수 클래스 만들기

- 갑자기 복소수는 왜?
	- Complex Number 에서는 [사칙연산](https://j1w2k3.tistory.com/1003)이 모두 재정의되므로, C++로 구현하려면 연산자 오버로딩을 해줘야 함

![[Pasted image 20230524135559.png]]

- 일단 하나의 복소수를 하나의 객체로 다룰거니깐, 복소수 클래스를 만들고, 복소수 관련 함수를 멤버함수로 정의해줘야 함.

```cpp
class Complex {
	private:
		double real, img;
	public:
		//생성자 with initializer list
		Complex(int real,int img): real(real), img(img) {}
}
```

- 사칙연산 함수 정의하기
	- $+, -, \times, \div$ 모두, 
	- 하나의 복소수 객체가 또 다른 복소수 객체를 (안바꿀꺼니깐) 상수 레퍼렌스 인자로 받아,  
	- 임시 복소수 객체를 리턴해야 함.

```cpp
class Complex {
	...
	Complex plus(const Complex& c);
	Complex minus(const Complex& c);
	Complex times(const Complex& c);
	Complex divide(const Complex& c);
}

Complex Complex::plus(const Complex& c){
	Complex temp(real+c.real, img+c.img);
	return temp;
}
```

- 연산자 오버로딩 없이 사칙연산 사용할 때, 
	-  `a + b / c + d` 는 ...
	- `a.plus(b.divide(c)).plus(d)` 라고 써야함
	- 더 간단하게 하고 싶으면 ? 
		- plus $\rightarrow$ $+$, minus $\rightarrow$ $-$, times $\rightarrow$ $*$, divide $\rightarrow$ $/$ 로 연산자 오버로딩 해주자!
		- `plus`의 연산내용을 `operator+` 함수로 정의해도 되고,
		- `plus` 함수 만들고나서, `operator+` 함수에서 호출해도 됨

```cpp
// 클래스 안에서 선언
Complex operator+(const Complex& c);
Complex operator-(const Complex& c);
Complex operator*(const Complex& c);
Complex operator/(const Complex& c);

// 클래스 밖에서 정의
Complex Complex::operator+(const Complex& c){
	return plus(c);
}
// 나머지도 같은 식으로~
```

---

# 대입 연산자 오버로딩

- `=` 연산자는 어떻게 만들지?
	- \*this에 우측 Complex 객체의 내용을 assign 하는거니깐,
	- 우측 Complex 객체의 내용으로 \*this 내용을 업데이트 하고,
	- \*this를 레퍼런스 리턴해서 기존객체의 내용이 업데이트 되도록 만들자.
	- 만들기 귀찮으면?
		- 따로 연산자 오버로딩 안 한 경우, 
		- 복사생성자를 컴파일러가 호출해주니깐, 
		- 복사생성자만 잘 만들어주면 돼

- Tip: 깊은 복사가 필요한 클래스의 복사연산자나 `operator=` 는 주의해서 만들자!
	- 동적할당 되는 메모리 있으면,
	- 그 부분을 복사해서 따로 만들고 포인터로 가리키게 하기!

```cpp
Complex& Complex::operator=(const Complex& c){
	real = c.real;
	img = c.img;
	return *this;
}
```

- `operator+=`, `operator-=`, `operator*=`, `operator/=` 에 같은 방법 적용!

---

# 잡다한 연산자의 오버로딩


## 이항 연산자 함수의 두 가지 형태

```cpp
// string으로 복소수 객체만드는 생성자와, 
// string으로 바로 + 연산 할 수 있는 +연산자 오버로딩을 한 경우,
Complex::Complex(const char* str) {...} 
Complex& Complex::operator=(const char* str){...}

// 이건 되는데,
a = a + "-1.1 + i3.929";
// 이건 안된다!
a = "-1.1 + i3.929" + a;
```

이렇게 이항 연산자 (두개의 항을 갖는 연산자인) 의 앞에 있는 인자가, 연산자 오버로딩 되어 있는 클래스의 객체가 아닌 경우, 어떡하지?
- 컴파일러는 이항 연산자를 두 가지 방법으로 해석한다
	- `*a.operator@(b);` 
		- 이 방식은 연산자 앞에 있는 인자가 operator@함수의 정의를 포함하는 클래스의 객체여야 한다 
	- `*operator@(a,b);` 
		- 이 방식은 operator@함수가 특정 클래스에 포함되어 있지 않은 일반 함수다.

```cpp
// 아래같이 operator+를 인자가 두 개인 일반함수로 정의하면 문제 해결
Complex operator+(const Complex& a, const Complex& b) { 
	Complex temp(a);
	return temp.operator+(b); 
}
// 이제 이거 됨!
a = "-1.1 + i3.929" + a;
// 질문!! 왜 아래처럼 앞 인자를 str 인자로 안받아도 되는거지?
Complex operator+(const char* s, const Complex& b) { ... }
// 이유는 아래처럼, 컴파일러가 앞 인자를 해석할 때, 생성자를 호출하기 때문!!
operator+(Complex("-1.1 + i3.929"), a);
```

## "상수 레퍼런스 인자 객체"에 들어있는 "상수가 아닌 멤버함수" 호출?

```cpp
Complex operator+(const Complex& a, const Complex& b) { 
	Complex temp(a);
	return temp.operator+(b); 
}

```

 위의 덧셈 오버로딩 할 때, 왜 굳이 `a`를 `temp`로 복사해서 그 멤버함수를 호출하지?
- `return a+b` 하면 무한루프를 돌거고,
- `return a.operator+(b);` 를 하면 상수레퍼런스 a를 호출한 다음에 상수함수가 아닌 멤버함수인 a.operator+를 부르니깐 컴파일 오류 발생!!
- 따라서,
	- 느린 방법: 상수레퍼런스a를 복사한 temp (하지만 상수변수는 아닌!) 를 이용해 멤버함수를 호출해야한다.
	- 빠른 방법: `real = a.real + b.real;` 처럼 private변수에 접근해서 직접 더해주기!
		- 발생하는 문제? `a.real`은 private 변수라서 외부함수는 접근할 수가 없네? 
		- `friend` 키워드를 써주자!!

## friend 는 모든 것을 공유한다

```cpp
class Complex {
	...
	public:
		...
		friend Complex operator+(const Complex& a, const Complex& b);
};
// Complex 클래스안에서 fried로 선언해줬으니깐, 이제 private 변수에 접근할 수 있다!!
Complex operator+(const Complex& a, const Complex& b){
	Complex temp(a.real + b.real, a.img + b.img);
	return temp;
}
```

위처럼 외부함수를 friend 선언할 수도 있고, 다른 클래스를 friend 선언 할 수도 있다.

```cpp
class A {
	...
	friend B;
}
class B {
	...
}
// 이러면, class B는 class A의 private 변수에 접근할 수 있게 됨!
```

## 입출력 연산자 오버로딩 하기


## 첨자 연산자 오버로딩 하기


## int Wrapper 클래스 - 타입 변환 연산자

기본 자료형의 wapper 클래스?
- 기본 자료형들을 객체로써 다루어야 할 때가 있음
- 예를 들어, int 자료형을 감싸는 int Wrapper 클래스 Int 를 만들고
- `Int x = 3; int a = x + 4` 처럼 int wrapper 클래스를 int operator랑 잘 섞이게 하고 싶으면,
- 일단 기본 생성자 잘 만들어주고,
	- int $\rightarrow$ Int : int를 인자로 받는 생성자 `Int::Int(int data)` 만들자.
	- 디폴트 대입연산자를 사용하면 이 생성자가 호출됨
- 타입 변환 연산자를 오버로딩하면 됨!
	- `Int::operator int() {return data;}`
	- 컴파일러가 Int를 int로 타입변환 할 때 이 타입변환 연산자가 호출됨
![[Pasted image 20230604234452.png]]


## 전위/후위 증감 연산자





---

# Reference

- [씹어먹는 C++ 5 - 1. 내가 만든 연산자 - 연산자 오버로딩](https://modoocode.com/202)
- [씹어먹는 C++ 5 - 2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩](https://modoocode.com/203)
- [씹어먹는 C++ 5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열](https://modoocode.com/204)