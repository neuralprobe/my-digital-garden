---
title: 연산자 오버로딩
date: 2023-05-25
tags: C++ OOP OperatorOverloading
---

# 연산자 오버로딩

- 앞선 [[객체지향프로그래밍의 시작]]에서 만든 MyString 클래스의 멤버함수 중 
	- `compare` 함수를 `==` operator로 바꾸자!
	- `insert` 함수를 `+` operator로 바꾸자!
	- `at` 함수를 `[]` operator로 바꾸자!
```cpp
	if(str1.compare(str2)==0) { ... }
->  if(str1 == str2) { ... } // 더 자연스러운 표현!!

	str1.insert(str1.length(), str2)
->  str1 = str1 + str2; // 더 자연스러운 표현!!

	x = str1.at(10);
->  x = str1[10]; // 더 자연스러운 표현!!
```

- 어떤 연산자가 오버로딩 할 수 있냐면 ....
	- `::`연산자 (범위 지정), `.` 연산자 (멤버 지정) , `*` (멤버 포인터로 멤버 지정) 을 제외한 모든 연산자를 오버로딩 할 수 있음.

![[Pasted image 20230524122457.png]]

---

## MyString의 == 연산자 오버로딩

- 오버로딩할 연산자 함수 선언 형식
	- `{리턴타입} operator{연산자}({연산자가 받는 인자})`
	- eg. `bool operator==(MyString& str)`
		- 그러면 .. `if (str1 == str2)` 처럼 `==` 연산자 사용가능
		- 비교하는 함수인 `compare`도 만들어 놨으니깐, 아래처럼 재활용하자

```cpp
class MyString {
	public:
		...
		bool operator==(MyString& str);
};

bool MyString::operator==(MyString& str) { 
	return !compare(str); 
	// *this와 str이 같으면 compare 에서 0 을 리턴
}	
```

---

## 복소수 클래스 만들기

- 갑자기 복소수는 왜?
	- Complex Number 에서는 [사칙연산](https://j1w2k3.tistory.com/1003)이 모두 재정의되므로, C++로 구현하려면 연산자 오버로딩을 해줘야 함

![[Pasted image 20230524135559.png]]

- 일단 하나의 복소수를 하나의 객체로 다룰거니깐, 복소수 클래스를 만들고, 복소수 관련 함수를 멤버함수로 정의해줘야 함.

```cpp
class Complex {
	private:
		double real, img;
	public:
		//생성자 with initializer list
		Complex(int real,int img): real(real), img(img) {}
}
```

- 사칙연산 함수 정의하기
	- $+, -, \times, \div$ 모두, 
	- 하나의 복소수 객체가 또 다른 복소수 객체를 (안바꿀꺼니깐) 상수 레퍼렌스 인자로 받아,  
	- 임시 복소수 객체를 리턴해야 함.

```cpp
class Complex {
	...
	Complex plus(const Complex& c);
	Complex minus(const Complex& c);
	Complex times(const Complex& c);
	Complex divide(const Complex& c);
}

Complex Complex::plus(const Complex& c){
	Complex temp(real+c.real, img+c.img);
	return temp;
}
```

- 연산자 오버로딩 없이 사칙연산 사용할 때, 
	-  `a + b / c + d` 는 ...
	- `a.plus(b.divide(c)).plus(d)` 라고 써야함
	- 더 간단하게 하고 싶으면 ? 
		- plus $\rightarrow$ $+$, minus $\rightarrow$ $-$, times $\rightarrow$ $*$, divide $\rightarrow$ $/$ 로 연산자 오버로딩 해주자!
		- `plus`의 연산내용을 `operator+` 함수로 정의해도 되고,
		- `plus` 함수 만들고나서, `operator+` 함수에서 호출해도 됨

```cpp
// 클래스 안에서 선언
Complex operator+(const Complex& c);
Complex operator-(const Complex& c);
Complex operator*(const Complex& c);
Complex operator/(const Complex& c);

// 클래스 밖에서 정의
Complex Complex::operator+(const Complex& c){
	return plus(c);
}
// 나머지도 같은 식으로~
```

---

## 대입 연산자 오버로딩

- `=` 연산자는 어떻게 만들지?
	- \*this에 우측 Complex 객체의 내용을 assign 하는거니깐,
	- 우측 Complex 객체의 내용으로 \*this 내용을 업데이트 하고,
	- \*this를 레퍼런스 리턴해서 기존함수의 내용이 업데이트 되도록 만들자.
	- 만들기 귀찮으면?
		- 따로 연산자 오버로딩 안 한 경우, 
		- 복사생성자를 컴파일러가 호출해주니깐, 
		- 복사생성자만 잘 만들어주면 돼

- Tip: 깊은 복사가 필요한 클래스의 복사연산자나 `operator=` 는 주의해서 만들자!
	- 동적할당 되는 메모리 있으면,
	- 그 부분을 복사해서 따로 만들고 포인터로 가리키게 하기!

```cpp
Complex& Complex::operator=(const Complex& c){
	real = c.real;
	img = c.img;
	return *this;
}
```

- `operator+=`, `operator-=`, `operator*=`, `operator/=` 에 같은 방법 적용!

---

To be continued ...



---

# Reference

- [씹어먹는 C++ 5 - 1. 내가 만든 연산자 - 연산자 오버로딩](https://modoocode.com/202)
- [씹어먹는 C++ 5 - 2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩](https://modoocode.com/203)
- [씹어먹는 C++ 5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열](https://modoocode.com/204)